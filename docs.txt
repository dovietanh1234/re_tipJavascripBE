FILE GHI CHÚ:

dự án cũ đây là 1 dự án đã cấu hình rapidMQ kết nối với dự án BE 2 => tạo thành một microservice
npm i amqplib --save // để config rapidMQ


BUỔI 1 cấu hình dự án Node js

folder: 
utils - là chứa các hàm( chuyển đổi ký tự hoa sang ký tự thường, prevent XSS, chuyển đổi ký tự ) ... ta thường hay sử dụng (Tần suất sd nhiều)
configs - lưu trữ cài đặt -> tuỳ chọn cấu hình cho ứng dụng của chúng ta ( JSON, XML ... )
helper - giúp chúng ta làm nhiều việc hơn (cần sd ms gọi)

npm i express --save
npm i morgan --save-dev // la 1 framework se console log ra cai trang thai cua request do! vd: time response, IP, time request, method GET, status ...
-> co 5 loai morgan (dev, common, combine, short, tiny ...)
npm i helmet --save
npm i compression --save  // khi van chuyen du lieu(payload) qua nang -> tốn băng thông -> compress giúp giảm băng thông gấp 10 lần (data nhẹ hơn)

BUỔI 2: connect DB mongoose ( 7 điều cần làm trong hệ thống )

npm i mongoose --save


Đoạn mã:
“if( 1 === 0 )
{ 
    mongoose.set(‘debug’, true) 
    mongoose.set(‘debug’, { color: true }) 
}” // print all activities when we perform query:
trong đoạn mã Node.js của bạn được sử dụng để thiết lập chế độ gỡ lỗi (debug mode) cho Mongoose, 
một Object Data Modeling (ODM) library cho MongoDB.

Tuy nhiên, điều kiện “1 === 0” luôn trả về false, nghĩa là đoạn mã bên trong không bao giờ được thực thi. 
Điều này có thể là do người phát triển muốn tắt chế độ gỡ lỗi và thay vì xóa đoạn mã, 
họ đã đặt điều kiện không bao giờ đúng.

Nếu bạn muốn kích hoạt chế độ gỡ lỗi, bạn có thể thay đổi điều kiện thành “1 === 1” hoặc một điều kiện khác
mà bạn biết chắc chắn sẽ trả về true. Khi chế độ gỡ lỗi được kích hoạt, 
Mongoose sẽ ghi lại tất cả các truy vấn MongoDB được thực thi. Cờ { color: true } sẽ làm cho log có màu, 
giúp dễ nhìn hơn.

=> single ton là tạo 1 class -> trong class tạo constructor chứa function init DB -> tạo 1 function init DB là oke!



BUỔI 4 .env
bảo mật thông tin nhạy cảm
.env lưu trữ thông tin nhạy cảm
config -> lưu trữ thông tin cấu hình cho dự án

npm i dotenv --save
-> sd file .env

BUỔI 5 Api Sign-up Shop

_Tải PACKAGE CHO VISUAL:
mongo snippets for node js: 
HTTP Client (file chỉ cẩn .http -> nó sẽ ra phương test cho chúng ta)
npm i bcrypt --save
npm i crypto --save
npm i jsonwebtoken --save

thêm middleware để nhận tham số từ body vào và cho phép trả về json:
app.use(expres.json());
// ở express version 4 người ta đã hỗ trợ url code rồi nên ko phải cài bodyParser nữa nhé thay vào đó:
app.use( express.urlencoded({
    extended: true     // chúng ta muốn mở rộng URL này ra!
}))

model -> service

* Bây giờ có 2 cách viết:
1 viết ES5 (dạng function)
2 viết ES6 (dạng class) -> h ta sẽ áp dụng dạng này vào dự án!

access trong Routers để chúng ta quản lý các signup, login, refresh token, sign in ...



* nguyên tắc của lập trình ko được nhúng một số hay một chuỗi nào vào code!
* trong class service -> chúng ta sẽ viết hàm có static => Tại vì chúng ta sẽ làm việc với model và service nhiều
chúng ta viết static thì ta chỉ cần gọi PACKAGE này chấm một cái là nó ra function chứ không CẦN new instance() ... 
* Java người ta hay viết bằng lập trình hướng đối tượng viết đối tượng này tái xử dụng đối tượng kia( tính đa hình đóng gói ) -> Hướng đối tượng
nhưng ở Javascript người ta sẽ thay vì hướng đối tượng (xử lý đối tượng) người ta sẽ hướng về module export module ... 
thay vì hướng đối tượng Ta sẽ hướng module này vào module kia ... đóng gói trong tính module đó => JS lập trình hướng đối tượng Module
* nếu như bình thường sử dụng một cái Key secret để vừa sign vừa verify nó là một sai lầm phổ biến nhất hiện nay khi người ta bắt được cái 
key secret của chúng ta người ta sẽ bắt được cái chữ ký của chúng ta và họ sẽ có thể tạo ra chữ ký của chúng ta luôn => hệ thống ngày nay 
người ta sẽ tách biết 2 key private key & public key 