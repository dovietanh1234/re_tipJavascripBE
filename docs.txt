FILE GHI CHÚ:

dự án cũ đây là 1 dự án đã cấu hình rapidMQ kết nối với dự án BE 2 => tạo thành một microservice
npm i amqplib --save // để config rapidMQ


BUỔI 1 cấu hình dự án Node js

folder: 
utils - là chứa các hàm( chuyển đổi ký tự hoa sang ký tự thường, prevent XSS, chuyển đổi ký tự ) ... ta thường hay sử dụng (Tần suất sd nhiều)
configs - lưu trữ cài đặt -> tuỳ chọn cấu hình cho ứng dụng của chúng ta ( JSON, XML ... )
helper - giúp chúng ta làm nhiều việc hơn (cần sd ms gọi)

npm i express --save
npm i morgan --save-dev // la 1 framework se console log ra cai trang thai cua request do! vd: time response, IP, time request, method GET, status ...
-> co 5 loai morgan (dev, common, combine, short, tiny ...)
npm i helmet --save
npm i compression --save  // khi van chuyen du lieu(payload) qua nang -> tốn băng thông -> compress giúp giảm băng thông gấp 10 lần (data nhẹ hơn)

BUỔI 2: connect DB mongoose ( 7 điều cần làm trong hệ thống )

npm i mongoose --save


Đoạn mã:
“if( 1 === 0 )
{ 
    mongoose.set(‘debug’, true) 
    mongoose.set(‘debug’, { color: true }) 
}” // print all activities when we perform query:
trong đoạn mã Node.js của bạn được sử dụng để thiết lập chế độ gỡ lỗi (debug mode) cho Mongoose, 
một Object Data Modeling (ODM) library cho MongoDB.

Tuy nhiên, điều kiện “1 === 0” luôn trả về false, nghĩa là đoạn mã bên trong không bao giờ được thực thi. 
Điều này có thể là do người phát triển muốn tắt chế độ gỡ lỗi và thay vì xóa đoạn mã, 
họ đã đặt điều kiện không bao giờ đúng.

Nếu bạn muốn kích hoạt chế độ gỡ lỗi, bạn có thể thay đổi điều kiện thành “1 === 1” hoặc một điều kiện khác
mà bạn biết chắc chắn sẽ trả về true. Khi chế độ gỡ lỗi được kích hoạt, 
Mongoose sẽ ghi lại tất cả các truy vấn MongoDB được thực thi. Cờ { color: true } sẽ làm cho log có màu, 
giúp dễ nhìn hơn.

=> single ton là tạo 1 class -> trong class tạo constructor chứa function init DB -> tạo 1 function init DB là oke!



BUỔI 4 .env
bảo mật thông tin nhạy cảm
.env lưu trữ thông tin nhạy cảm
config -> lưu trữ thông tin cấu hình cho dự án

npm i dotenv --save
-> sd file .env

BUỔI 5 Api Sign-up Shop

_Tải PACKAGE CHO VISUAL:
mongo snippets for node js: 
HTTP Client (file chỉ cẩn .http -> nó sẽ ra phương test cho chúng ta)
npm i bcrypt --save
npm i crypto --save
npm i jsonwebtoken --save
npm i lodash --save // sử dụng để truyền metadata trong json về cho ứng dụng rất gọn nhẹ và tiện lợi

thêm middleware để nhận tham số từ body vào và cho phép trả về json:
app.use(expres.json());
// ở express version 4 người ta đã hỗ trợ url code rồi nên ko phải cài bodyParser nữa nhé thay vào đó:
app.use( express.urlencoded({
    extended: true     // chúng ta muốn mở rộng URL này ra!
}))

model -> service

* Bây giờ có 2 cách viết:
1 viết ES5 (dạng function)
2 viết ES6 (dạng class) -> h ta sẽ áp dụng dạng này vào dự án!

access trong Routers để chúng ta quản lý các signup, login, refresh token, sign in ...


BUỔI 6: cấu hình middleware linh động cho API KEY PERMISSION: CHECK AN TOÀN CỦA MỘT CÁI ROUTER -> phải viết APIKEY
Một cái hệ thống API đó có sử dụng cái version của chúng ta ko cách xử lý đó là
tạo api key
tạo một bảng lưu các api key ( key, status, permission )

1. api key -> sẽ được tạo bởi chúng ta -> admin sẽ cung cấp cái key này 
2. người dùng sẽ cần key này! để add vào header của service! để kèm theo
3. sau đó: trên server sẽ verify nó nếu mà nó phù hợp trong DB của chúng ta thì chúng ta sẽ cho pass qua

_ Khi bạn gán req.objKey = objKey;, bạn đang thêm một thuộc tính mới có tên là objKey vào đối tượng req. 
Giá trị của thuộc tính này là objKey, đối tượng bạn đã tìm thấy từ cơ sở dữ liệu.
Sau đó, bạn có thể truy cập req.objKey trong bất kỳ middleware hoặc route handler nào tiếp theo trong chuỗi xử lý yêu cầu. 
Điều này cho phép bạn chia sẻ dữ liệu giữa các phần khác nhau của ứng dụng mà không cần truy vấn cơ sở dữ liệu nhiều lần.
=> nghĩa là tôi có thể gán một đối tượng object (Database) vào cho object req để ứng dụng có thể kiểm tra những lần sau ...
ex: req.objKey.name == "hoang"

BÀI 7 xử lý errorHandler trong API:
=> Cách return về error thống nhất ngữ cảnh!
_ ko phải lúc nào cx xử dụng try catch => vì vậy ta sẽ xử lý lỗi exception khi có một sự cố xảy ra



BÀI 8: Cách tạo một class success response:
=> Cách trả về success thống nhất ngữ cảnh!
-> thống nhất ngữ cảnh của một công ty một nhóm ... 

Bài 9: Login Shop Api
_ xoá cái model "keyTokenSchema" cũ đi thay bằng một model mới ( dùng để lưu các refresh-token đã sử dụng và cái mới )

_ refresh-tokenn được gửi khi login làm gì? -> khi người ta login lại nhưng mà Có cookie rồi!
-> thì FE phải mang cái cookie đó đi theo Để chúng ta biết -> Cái thằng này xưa là nó đang sử dụng cái token này! 
và Bây giờ nó muốn login lại -> thì ta phải xoá cái token cũ đi đỡ phải truy vấn vào DB! 

const findByEmail = async ({email, select = {
    email: 1, password: 1, name: 1, status: 1, roles: 1
}}) => {
    return await shopModel.findOne({email}).select(select).lean();
    // receive the value and transfer for "select" parameter through method ".select()"
}
.select(select) sẽ chỉ chọn các trường được định nghĩa trong đối tượng select để trả về trong kết quả. 

_ tối ưu thì sử dụng await còn nếu muốn sử dụng đồng bộ ko chặn sử dụng .then()


Bài 10: logout vs Authentication
-> thằng này có đúng là chính chủ muốn logout hay ko? 
-> viết một Authentication để verify cái access token ... có phải là chính nó hay ko?


Bài 11: xử lý token được sử dụng trái phép và cách xử lý:
_ hacker lấy được (refresh-token & access-token và sử dụng)
_ ta cùng đang sử dụng (refresh-token & access-token đó)
-> khi access token hết hạn nó sẽ trả về access-token và refresh-token mới cho hacker or Client ( HỆ THỐNG lưu refresh token hết hạn vào black list)
-> Và bây giờ hacker or User đang sử dụng tokens mới 
Nhưng hacker or user còn lại sẽ tiếp tục gửi access-token & refresh token để lấy dữ liệu
và truy cập => LÚC NÀY HỆ THỐNG SẼ PHÁT HIỆN LỖI vì ở trong Black-list ta đã lưu thông tin của refresh-token cũ 

=> Hệ thống sẽ Huỷ toàn bộ các refresh-token và access-token hiện tại của USER OR HACKER ( diết nhầm còn hơn bỏ sót )
=> Vậy thì lúc này ai có password người đó sẽ có thể vào lấy lại được access-token & refresh-token mới!

BÀI 12 13: schema product ecommerce - Cách thiết kế hàng triệu sản phẩm và tối ưu hoá nhanh:
Database -> bắt nguồn từ thiết kế schema hoàn chỉnh Đúng cú pháp -> tăng tốc ứng dụng của chúng ta rất là nhanh
 Tìm hiểu về kiến trúc lược đồ của product
 
 polymorphic pattern (1)
 product:
 product_name
 product_price
 product_sold
 product_thumb
atribute_child( different )

"Schema.Types.Mixed" => cho phép lưu trữ các models riêng của của attributes( sẽ có nhiều đối tượng và ta sẽ cho phép nó được 
lưu theo kiểu đối tượng khác nhau ví dụ: clothing, electronic ... mỗi đối tượng sẽ có kiểu properties khác nhau nhưng ta đều cho
phép lưu vào trong model ) 

"super()" chính là gọi class cha! -> Điều này giúp bạn tránh lặp lại các đoạn code giống nhau trong các lớp con và lớp cha.

Factory pattern Product ( đưa child Product Clothing, Electronic...  )  
Parent Product( tạo Product với các common properties )  ->     child Product Clothing, Electronic... extends Product ( tạo attribute Clothing, Electronic ... trước rồi đến tạo Product sau! )


BÀI 14: Tối ưu lại API SERVICE Products (optimal)
Logic -> tối ưu tốc độ
update logic ... 

xử lý lấy userId từ refresh-token
xử lý thay đổi dữ liệu attribute model clothing có thêm trường product_shop, và id của nó sẽ trùng lặp với id của Product cha của nó
-> truy vấn cho đúng

sử dụng toán từ "spread opertator " giải các giá trị cũ vào và thêm dữ liệu mới cho trường nhất định.

-> Nhược điểm đang xảy ra nếu chúng ta thêm một attribute like: Furniture, Computer ... thì chùng ta sẽ lại phải sửa class FactoryProduct:
trong kiến trúc của SOLID -> chúng ta ko nên động chạm vào đóng mở sửa đổi ở class Factory ...

BÀI 15: SỬA LẠI FactoryProduct không bị vi phạm nguyên tắc trong lập trình SOLID ( độ phức tạp cao hơn )

BÀI 16: Add tính năng isDraft, isPubic, unPublic bổ sung schema Product Service API!
-> design and add more properties in Product Model ( rating, slug, isDraft, isPubic ... )
npm i slugify --save

_ slug rất quan trọng vì nó là "Slug là phần quan trọng của URL"
class "RegExp()" -> new RegExp();  trong node js:
nó dùng để tạo ra các đối tượng biểu thức chính quy (regular expression)

_ Biểu thức chính quy là một chuỗi "đặc biệt" ĐƯỢC DÙNG ĐỂ SO KHỚP VỚI CÁC CHUỖI KHÁC THEO MỘT MẪU NHẤT ĐỊNH:
ví dụ:
const regex = new RegExp("Nguyen");

console.log( regex.test("Nguyen Van A") ); // true
console.log( regex.test("Do Viet Anh") );// false

sử dụng đánh index cho trường dữ liệu name và description:
productSchema.index({ product_name: 'text', product_description: 'text' })

Mục đích: 
-> Đây là một cách để tạo ra một chỉ mục văn bản (text index) cho các trường dữ liệu đó!
-> giúp Ta có thể thực hiện các truy vấn tìm kiếm văn bản (text search) trên các trường đó một cách hiệu quả hơn!

Ví dụ: vì đoạn code trên ta đã đánh index cho trường product_name và product_description là "text" rồi nên bây giờ
ta CÓ THỂ sử dụng toán tử $text để tìm kiếm dữ liệu trong trường name OR description ...

Giải thích đoạn code search này:
model.js:
productSchema.index({ product_name: 'text', product_description: 'text' })
serive.js:
const searchProduct = async ({  keySearch })=>{
    const regexSearch = new RegExp(keySearch);
    // to easy query for result -> we need to assign index for userName & description:
    const results = await product.find(
        {$text: { $search: regexSearch }}, 
        {score: { $meta: 'textScore' } }   // "score" is the word it will search the most accurately
    )
}

1. Trong file model.js, ta đã tạo ra một chỉ mục văn bản (text index) cho hai trường dữ liệu product_name và product_description 
trong schema productSchema. giúp ta có thể thực hiện các truy vấn tìm kiếm văn bản (text search) trên các trường đó 
một cách hiệu quả hơn.

2. sử dụng phương thức find() của model product để tìm kiếm các document khớp với biểu thức chính quy của bạn, 
bằng cách sử dụng toán tử $text

3. truyền vào một đối tượng thứ hai để chỉ định một trường tên là score!
thằng này sẽ có giá trị kết quả là KẾT QUẢ của $meta: 'textScore'. 
Đây là một giá trị số thể hiện mức độ khớp của document với từ khóa tìm kiếm

=> Mục đích đưa "score" vào là để:
thể hiện mức độ khớp của document với từ khóa tìm kiếm. 
Giá trị này được tính dựa trên các yếu tố như số lượng và tần suất xuất hiện của từ khóa trong document, 
độ dài của document, và trọng số của các trường được chỉ mục. Bạn có thể sử dụng giá trị này để sắp xếp các document 
theo thứ tự giảm dần của score, để lấy ra các document phù hợp nhất với từ khóa tìm kiếm.

-Đúng vậy, khi bạn tìm kiếm được giá trị qua biểu thức "$text", 
nó sẽ đưa giá trị vào biến score để sắp xếp lại các giá trị tìm kiếm trả về.
Bạn có thể hiểu score là một chỉ số đo lường mức độ phù hợp của document với từ khóa tìm kiếm.
Càng cao score thì càng có nhiều khả năng document đó chứa từ khóa bạn muốn tìm











* nguyên tắc của lập trình ko được nhúng một số hay một chuỗi nào vào code!
* trong class service -> chúng ta sẽ viết hàm có static => Tại vì chúng ta sẽ làm việc với model và service nhiều
chúng ta viết static thì ta chỉ cần gọi PACKAGE này chấm một cái là nó ra function chứ không CẦN new instance() ... 
* Java người ta hay viết bằng lập trình hướng đối tượng viết đối tượng này tái xử dụng đối tượng kia( tính đa hình đóng gói ) -> Hướng đối tượng
nhưng ở Javascript người ta sẽ thay vì hướng đối tượng (xử lý đối tượng) người ta sẽ hướng về module export module ... 
thay vì hướng đối tượng Ta sẽ hướng module này vào module kia ... đóng gói trong tính module đó => JS lập trình hướng đối tượng Module
* nếu như bình thường sử dụng một cái Key secret để vừa sign vừa verify nó là một sai lầm phổ biến nhất hiện nay khi người ta bắt được cái 
key secret của chúng ta người ta sẽ bắt được cái chữ ký của chúng ta và họ sẽ có thể tạo ra chữ ký của chúng ta luôn => hệ thống ngày nay 
người ta sẽ tách biết 2 key private key & public key 
* toán tử optional chaining "?." => cho phép chúng ta truy cập vào một thuộc tính nằm sâu trong chuỗi các đối tượng mà không cần kiểm 
tra từng tham chiếu trong chuỗi có 'null' hay 'undefined' hay không? nếu một trong các chuỗi là 'null' or 'undefined' ... 
toán tử optional chaining "?." sẽ ngắt chuỗi và trả về undefined thay vì ném ra lỗi.

* closure -> trả về một cái hàm và cái hàm này thì có thể truy cập đến các phương thức của những thằng cha ...
ví dụ thằng cha 1 sử dụng hàm closure -> trả về 1 giá trị khác
      thằng cha 2 sử dụng hàm closure -> lại trả về 1 giá trị khác 
      Điểm chung là hàm thằng cha và hàm closure không thay đổi logic
      Điểm khác là tham số chuyền vào & có mấy thằng cha!

* Khi tạo schema bằng objectId và bây giờ ta sử dụng findOne mà sử dụng kiểu string thì nó sẽ ko bao h tìm được dữ liệu
chúng ta phải ép kiểu về objectId -> const {Types} = require('mongoose'); | .findOne( Types.objectId( UserId ) )
* 1 collection mongose DB -> 1 document giới hạn hiện tại là 16mb -> vượt quá 16mb (ko cho lưu nữa)
mongose DB cho phép chúng ta có 100 objects lồng nhau nested object 100 
mongose DB được thiết kế xử lý khối lượng lớn và Có thể mở rộng theo chiều ngang hay chiều dọc ... để xử lý dữ liệu nhiều hơn
